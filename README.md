
AIChallenge объединяет локальный чат-интерфейс, ИИ-агента и встроенный MCP‑сервер.
Ниже — краткий обзор ключевых компонентов и их взаимодействия.

## ChatScreen
Компонент Compose, показывающий историю сообщений, поле ввода и кнопки управления.
- Отображает `vm.messages` (список `ChatMessage`) и позволяет копировать ответы в буфер обмена.
- При монтировании вызывает `ChatViewModel.startIssueSummaryUpdates()`, при демонтировании — `stopIssueSummaryUpdates()`; так экран всегда подписан на поток обновлений от ИИ-агента только когда открыт.
- Кнопка «Очистить» делегирует вызов `vm.clearHistory()`.

## ChatViewModel
ViewModel инкапсулирует бизнес-логику чата и сеть.
- Метод `sendMessage()` отправляет пользовательский ввод через `LocalApi.chatWithRestrictions()` на ИИ-агента, добавляя user/assistant сообщения в локальное состояние.
- `startIssueSummaryUpdates()` открывает WebSocket (`ws://127.0.0.1:8080/issueSummary`). Через `SummarySocketListener` все входящие JSON‑события с `type = "issue_summary"` превращаются в новые сообщения бота.
- При ошибках сокет автоматически переподключается (с задержкой 2 секунды), пока чат активен.
- `onCleared()` гарантированно останавливает подписку и закрывает сокет.

## LocalAiServer (ИИ-агент)
Локальный сервер, наследующий `NanoWSD`, который:
- Обрабатывает REST‑эндпоинты `/chat`, `/history`, `/clear`. POST `/chat` формирует prompt для облачного YandexGPT (используя `callYandex()`) и, при необходимости, вызывает MCP‑инструменты.
- Ведёт историю диалога (`historyFile`), периодически компрессирует её и возвращает через `/history`, чтобы чат на клиенте мог восстановить состояние.
- Запускает фоновую корутину, которая каждые `ISSUE_SUMMARY_REFRESH_MS` (в режиме тестирования — 15 секунд) обращается к MCP‑инструменту `github_issue_comments`, формирует сводку и сохраняет её, попутно рассылая подписчикам.
- Поддерживает WebSocket `/issueSummary`: хранит активные соединения, отправляет последнюю сводку при подключении и поддерживает соединение heartbeat‑пингами, чтобы избежать `SocketTimeoutException`.

## McpServerManager
Обёртка над встроенным MCP‑сервером Ktor.
- Поднимает SSE‑транспорт (`/mcp`), чтобы ИИ-агент мог выполнять MCP‑вызовы через `McpClient`.
- Регистрирует инструменты, среди них — `github_issue_comments`, использующий GitHub REST API и токен из `local.properties`.
- ИИ-агент вызывает эти инструменты, когда в ответе YandexGPT появляется маркер `MCP_TOOL`, а также в фоновой задаче, формирующей сводку issue.
- Внутренние инструменты `dnd_characters`, `dnd_campaigns` и `dnd_spells_for_class` читают JSON из `app/src/main/assets/mcp`, позволяя модели получать описания героев, кампаний и заклинаний, используемых в приложении.

## Взаимодействие компонентов
1. **Пользователь** вводит запрос в `ChatScreen` → `ChatViewModel.sendMessage()` делает HTTP POST `/chat` на ИИ-агент.
2. **LocalAiServer** формирует prompt, при необходимости вызывает инструменты MCP через `McpClient`, затем возвращает ответ, логирует его в историю и рассылает (если это сводка) через WebSocket.
3. **ChatViewModel** получает HTTP‑ответ и добавляет его на экран, а параллельно держит WebSocket, который слушает новые issue‑сводки и мгновенно показывает их в `ChatScreen`.
4. **McpServerManager** обеспечивает доступ ИИ-агента к GitHub dati (issue comments) — без него инструмент `github_issue_comments` был бы недоступен.

Такая архитектура позволяет тестировать локального ИИ‑агента, взаимодействующего с MCP‑инструментами, и в реальном времени доставлять результаты пользователю через чат.
